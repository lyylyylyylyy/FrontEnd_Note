# 变量，作用域和内存问题

本文主要内容:
- 理解基本类型和引用类型的值
- 理解执行环境
- 理解垃圾收集

## 基本类型和引用类型的值

基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，即不能直接操作对象的内存空间。**在操作对象时，实际上是在操作对象的引用而不是实际的对象，为此，引用类型的值是按引用访问的**。

### 动态的属性

对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法。

```
var person = new Object();
person.name = "Nicholas";
alert(person.name);   // "Nicholas"
```

我们不能给基本类型的值添加属性，尽管这样不会导致任何错误。比如：

```
var name = "Nicholas";
name.age = 27;
alert(name.age)  // undefined
```

### 复制变量值

在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。

- 如果从一个变量向一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。**两个变量可以参与任何操作而不会相互影响。**

- 当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象的值复制一份到为新变量分配的空间中。不同的是，**这个副本是一个指针，这个指针指向存储在堆中的一个对象**，复制结束后，两个变量实际上将引用同一个对象。因此，**改变其中一个变量，就会影响另一个变量。**

### 传递参数

**ECMAScript中所有函数的参数都是按值传递的**。即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

在向函数参数传递引用类型的值时，会把这个值的内存地址赋值给一个局部变量，因此这个局部变量的会反映在函数的外部。

例1：
```
function addTen(num) {
    num + = 10;
    return num;
}

var count = 20;
var result = addTen(count);
alert(count);  // 20
alert(result);  //30
```

例2：
```
function setName(obj) {
    obj.name = "Nicholas";
}

var person = new Object();
setName(person);
alert(person.name); // "Nicholas"
```

例3：
```
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg"
}

var person = new Object();
setName(person);
alert(person.name); // "Nicholas"
```
例3中，如果person是按引用传递的，那么person就会自动被修改为指向其name属性为“Greg”的新对象。但是结果显示为"Nicholas"，这说明，即使在函数内部修改了参数的值，但是原始的引用仍然保持未变。实**际上，在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。**

> 可以把ECMAScript函数的参数想象成局部变量。

### 检测类型

`typeof`操作符是确定一个变量是字符串、数值、布尔值、还是`undefined`的最佳工具。如果变量的值是一个对象或者null，则会返回`object`。

在**检测引用类型**的值时，`typeof`的作用不大，要使用`instanceof`，可以知道它是什么类型的对象。

`result = variable instanceof constructor`

如果变量是给定引用类型的实例(根据原型链来识别)，那么`instanceof`就会返回`true`。**所有引用类型的实例都是object。**`instanceof`检测基本类型时，就会返回false，因为基本类型不是对象。

## 执行环境(执行上下文)及作用域

执行环境是JavaScript中的一个重要概念。

执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。

每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。

**全局执行环境是最外围的一个执行环境**。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——例如关闭网页/浏览器时才会被销毁)。

**每个函数都有自己的执行环境**。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中(执行上下文栈)。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

**当代码在一个环境中执行时，会创建变量对象的一个作用域链**。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即`arguments`对象。作用域链中的下一个变量来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。


标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止(若找不到，通常会导致错误发生)。

例：

```
var color = "blue";

function changeColor () {
    if (color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
}

changeColor();

alert("Color is now" + color);
```

在这个简单的例子中，函数changeColor()的作用域包含两个对象：它自己的变量对象(其中定义着arguments对象)和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到他。

此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面例子所示：

```
var color = "blue";

function changeColor () {
    var anotherColor = "red";

    function swapColors () {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;

        //这里可以访问color，anotherColor和tempColor
    }
    //这里可以访问color，anotherColor，但不能访问tempColor
    swapColors();
}
//这里只能访问color
changeColor();
```

以上代码共涉及三个执行环境：全局环境、changeColor()的局部环境和swapColors()的局部环境。作用域链如下：

```
window
  |______color
  |______changeColor()
               |_______anotherColor
               |_______swapColors()
                          |______tempColor
```

内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。

**每个环境可以向上搜索作用域链**，以查询变量和函数名；**但是任何环境都不能通过向下搜索作用域链而进入另一个执行环境**。

> 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。

### 延长作用域链

有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

- try-catch语句的catch块；
- with语句

这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对于catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。下面看一个例子:

```
function buildUrl() {
    var qs = "?debug=true";

    with(location) {
        var url = href + qs;  //href实际上是location.href
    }
    return url;
}
```

在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性，而这个变量对象被添加到了作用域链的前端。

### 没有块级作用域

JavaScript没有块级作用域经常会导致理解上的困惑。例如：

```
if (true) {
    var color = "blue";
}
alert(color);  //"blue";
```
上述代码中，在一个if语句中定义了变量color。若是在C，C++或Java中，color会在if语句执行完毕后被销毁。但是**在JavaScript中，if语句中，if语句中的变量声明会将变量添加到当前的执行环境中**。在使用for语句时，尤其要牢记这一差异，例如：

```
for (var i = 0;i < 10; i++) {
    doSomething(i);
}
alert(i) //10，循环结束后，变量i依旧存在于循环外部的执行环境中
```

#### 声明变量

**使用`var`声明的变量会自动被添加到最接近的环境中(变量提升)**。在函数内部中，最接近的环境是函数的局部环境，with语句中，最接近的是函数环境。如果初始化变量时没有使用`var`声明，该变量会被添加到全局环境。

例：

```
funtion add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}

var result = add(10, 20); //30

alert(sum) //错误
```

例：

```
funtion add(num1,num2) {
    sum = num1 + num2;
    return sum;
}

var result = add(10, 20); //30

alert(sum) //30,sum在全局环境中
```

> 在初始化变量之前一定要声明，可以避免一些常见的错误。在严格模式下，初始化未经声明的变量会导致错误。

#### 查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中页没有找到这个标识符，则意味着该变量尚未声明。

例：

```
var color = "blue";

function getColor() {
    return color;
}

alert(color);   // blue
```

例：

```
var color = "blue";

function getColor() {
    var color = "red";    // 向上查询找到，搜索结束
    return color;
}

alert(color);   // red
```

## 垃圾收集

JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。

这种垃圾收集机制的原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。因此，垃圾收集器会按照固定的时间间隔周期性的执行这一操作。

垃圾收集器必须跟踪那个变量有用哪个变量没有用，对于不再有用的变量打上标记，以备将来收回其占用的内存。标识无用变量的策略一般有2个。

### 标记清除

JavaScript最常用的垃圾收集方式是标记清除。当变量进入环境中时，就将这个变量标识为“进入环境”。

可以使用任何方式来标记变量。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

### 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当一个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

### 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

### 管理内存

分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存，可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其设置为null来释放引用——这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用。