# 前言

在众多高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的Node是首个。

**伴随着异步I/O的还有事件驱动和单线程，他们构成Node的基调。**

Node是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。

## 异步I/O的原因

这与Node面向网络设计有关。

### 用户体验

在浏览器中，JavaScript在单线程上执行，而且它还与UI渲染共用一个线程。这意味着，JavaScript在执行的时候UI渲染和响应是处于停滞状态的。

通过异步可以消除UI阻塞的现象，但是前端获取资源的速度也取决于后端响应的速度。

只有后端能够快速响应资源，才能让前端的体验更好。

### 资源分配

假设业务场景中有一组互不相关的任务需要完成，现行的主流方法有以下两种。

- 单线程串行依次执行
- 多线程并行完成

多线程的代价在于，创建线程和执行期线程上下文的切换开销较大。此外，在复杂的业务中，多线程编程经常面临死锁、状态同步等问题，但是多线程在多核CPU上能够有效提升CPU的利用率。

单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。

添加硬件资源是一种提升服务质量的方式，但它不是唯一的方式。

**Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好的使用CPU。**

为了弥补单线程无法利用多核cpu的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效的利用CPU和I/O。

## 异步I/O实现

### 异步I/O与非阻塞I/O

从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事。

操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果。**非阻塞I/O和阻塞I/O的差别为调用后会立即返回。**

*操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。**此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。***

非阻塞I/O返回后，CPU的时间片可以用来处理其他事物，此时的性能提升是明显的。

由于完成的I/O并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。**为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。**

这种重复调用判断操作是否完成的技术叫做**轮询**。

非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费。