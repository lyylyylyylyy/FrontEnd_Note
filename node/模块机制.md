# CommonJS规范

## CommonJS的模块规范

CommonJS对模块的定义十分简单，主要分为模块引用、模块定义、模块标识3个部分。

### 模块引用

模块引用的示例代码如下：

```
var math = require('math')
```

在CommonJS规范中，存在`require()`方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。

### 模块定义

在模块中，上下文提供`require()`方法来引入外部模块。对此引入的功能，上下文提供了`exports`对象用于导出当前模块的方法和变量，并且它是唯一的出口。在模块中，还存在一个module对象，它代表模块自身，而`exports`是`module`的属性。在Node中，一个文件就是一个模块，将方法挂载在`exports`对象上作为属性，即可定义导出的方式。

### 模块标识

模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者以`.`、`..`开头的相对路径，或者绝对路径。它可以没有文件名后缀`.js`。

CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染。

# Node的模块实现

在Node中引入模块，需要经历如下3个步骤：

- 路径分析
- 文件定位
- 编译执行

在Node，模块分为两类：一个是Node提供的模块，称为**核心模块**；另一类是用户编写的模块，称为**文件模块**。

- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以它的加载速度是最快的。
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块快慢。

## 优先从缓存加载

与前端浏览器会缓存静态文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。

不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用**缓存优先**的方式，这是第一优先级的。

## 路径分析和文件定位

### 模块标识符分析

`require()`方法接收一个标识符作为参数。模块标识符在Node中主要分为以下几类。

- 核心模块，如http、fs、path等。
- `.`或`..`开始的相对路径文件模块。
- 以`/`开始的绝对路径文件模块。
- 非路径形式的文件模块，如自定义的connect模块。

**核心模块：**

核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。

**路径形式的文件模块：**

分析文件模块时，`require()`方法将路径转换为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以使二次加载更快。

加载速度仅慢于核心模块。

**自定义模块：**

这类模块查找是所有方式中最慢的一种。

模块路径是Node在定位文件模块的具体文件时制定的查找策略。

模块路径的生成规则如下：
- 当前文件目录下的`node_modules`目录。
- 父目录下的`node_modules`目录。
- 父目录的父目录下的`node_modules`目录。
- 沿路径向上逐级递归，直到根目录下的`node_modules`目录。

### 文件定位

**文件拓展名分析**:

若标识符不包含文件拓展名，Node按照`.js`、`.json`、`.node`的次序补足拓展名，依次尝试。

**目录分析和包**：

Node在当前目录下查找package.json，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。

## 模块编译

编译和执行是引入文件模块的最后一个阶段。对于不同的文件拓展名，其载入方法也有所不同。
- `.js`：通过fs模块同步读取文件后编译执行。
- `.node`：dlopen
- `.json`：fs同步读取，JSON.parse解析返回结果。
- 其余文件拓展名：当作`.js`。

### JavaScript模块的编译

编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。这样每个模块之间都进行了作用域隔离。

### C/C++模块的编译

process.dlopen()方法进行加载执行。

### JSON文件的编译

fs同步读取，JSON.parse解析返回结，将他赋给模块对象的exports，以供外部调用。

