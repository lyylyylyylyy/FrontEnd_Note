## let命令

### 基本用法

ES6新增了`let`命令，用来声明变量，类似于`var`，但是**所声明的变量，只在`let`命令所在的代码块有效**。

```
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
```

上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。

### 不存在变量提升

`var`命令会发生“变量提升”现象，即变量可以在声明前使用，值为`undefined`。

`let`声明的变量一定要在声明后使用，否则报错。

```
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

### 暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就会绑定在这个区域，不再受外部的影响。

```
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```
> 上述代码，存在全局变量`tmp`，但是块级作用域又声明了一个局部变量`tmp`，导致后者绑定在这个块级作用域，所以在`let`声明这个变量前会报错。

**ES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。**

在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**（temporal dead zone，简称TDZ）。

暂时性死区意味着**typeof不再是一个百分之百安全的操作**
```
typeof x; // ReferenceError

let x;

let x = x;
```
上面代码中，变量x使用`let`命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。

作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。

`typeof undeclared_variable // "undefined"`

ES6规定暂时性死区以及`let`和`const`不出现变量提升，主要是为了减少运行时的错误，防止在变量声明前就使用这个变量。

### 不允许重复声明

`let`不允许在相同作用域内，重复声明同一个变量。

### 块级作用域

为什么要有块级作用域？

ES5只有全局作用域和函数作用域。

```
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```

上面代码的原意是，if代码块的外部使用外层的`tmp`变量，内部使用内层的`tmp`变量。但是，函数f执行后，输出结果为`undefined`，原因在于**变量提升**，导致内层的`tmp`变量覆盖了外层的`tmp`变量。

第二种场景，用来计数的循环变量泄露为全局变量。
```
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

### ES6的块级作用域

`let`实际上为JavaScript新增了块级作用域。

```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```
上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示**外层代码块不受内层代码块的影响**。如果两次都使用var定义变量n，最后输出的值才是 10。

ES6允许块级作用域的任意嵌套。

内层作用域可以定义外层作用域的同名变量。

### 块级作用域与函数声明

- 允许在块级作用域内声明函数
- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头
- 同时，函数声明还会提升到所在的块级作用域的头部

> 注意：应该避免在块级作用域内声明函数
> ES6的块级作用域必须有`{}`，如果没有大括号，JavaScript引擎就认为不存在块级作用域。

## const命令

### 基本用法

`const`声明一个只读的常量，不得改变值。

`const`的作用域与`let`相同：只在声明所在的块级作用域内有效。

`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

本质：

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。

对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

**ES6声明对象的六种方式**：

ES5 只有两种声明变量的方法：`var`命令和`function`命令。ES6 除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6 一共有 6 种声明变量的方法。

### 顶层对象的属性

**顶层对象**，在**浏览器中指的是window对象**，在**Node中指的是global对象**。ES5之中，顶层对象的属性与全局变量是等价的。

ES6为了改变这一点，为了保持兼容性，规定，`var`和`function`声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令和`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从SE6开始，全局变量将逐步与顶层对象的属性脱钩。

```
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```
上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。

### globalThis对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，**顶层对象在各种实现里面是不统一的**。

- 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
- Node 里面，顶层对象是global，但其他环境都不支持。
  
**同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性**。

- 全局环境中，`this`会返回顶层对象。但是，Node 模块和 ES6 模块中，`this`返回的是当前模块。
- 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。
- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了 `CSP（Content Security Policy，内容安全策略）`，那么`eval`、`new Function`这些方法都可能无法使用。

ES2020 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

垫片库`global-this`模拟了这个提案，可以在所有环境拿到`globalThis`。