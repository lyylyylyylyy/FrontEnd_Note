事件冒泡：事件开始由最具体的元素接收，逐级向上传播，一般是直到document对象。

事件捕获：document对象接收事件，事件一直向下传播直到具体目标。

DOM事件流：事件捕获，目标阶段和事件冒泡。

- 事件处理程序，这个函数中存在event这个局部变量，即事件对象。
- event可以直接访问事件对象


动态创建的函数，使用with拓展作用域，目的是让事件处理程序无需引用表单元素就能访问其他表单字段。

```javascript
function () {
    with(document) {
        with(this) {
            // 元素属性值
        }
    }
}
```

html中指定事件处理程序的缺点：
- 时差问题：用户可能在元素一出现在页面上就触发相应的事件，但当时事件处理程序可能不具备执行条件，这样会报错，所以一般会使用一个try-catch封装事件处理程序。
- 这样扩展事件处理程序的作用域链在不同浏览器中会有不同的结果。
- html和javascript代码紧密耦合。

DOM0级事件处理程序：获得一个操作对象，然后`btn.onclick=function()...`
- 这种方式添加的事件处理程序在事件流的冒泡阶段被处理
- 删除：将事件处理程序设置为null

DOM2级事件处理程序：
- addEventListener
- removeEventListener：addEventListener添加的事件处理程序只能这样移除，传入的参数都一样，所以addEventListener添加的匿名函数没办法移除
- 所有DOM节点都有这两个方法
- 三个参数：事件名，事件处理程序的函数，布尔值(true：捕获阶段执行事件处理程序；false：冒泡阶段执行)
- 优点：添加多个事件处理程序
- 推荐在冒泡阶段执行事件处理程序，可以最大限度兼容各种浏览器
- 同一个元素添加多个事件处理程序（同一阶段执行），按照顺序执行相应函数

IE事件处理程序:
- attachEvent()
- detachEvent()
- 两个参数：事件处理程序名称，事件处理函数
- 事件处理程序都会添加到冒泡阶段
- 同一个元素添加多个事件处理程序（同一阶段执行），按照相反的顺序执行相应函数
- 匿名函数不能被移除

**作用域**:
- DOM0级方法：事件处理程序会在其所属元素的作用域内运行
- 使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window

跨浏览器的事件处理程序：
- 要保证处理事件的代码能在大多数浏览器下一致低运行，只需要关注冒泡阶段。
- 检测是否存在DOM2级方法，是否存在ie方法，如果不存在，使用DOM0级方法。

---------------------------------------------------------------------------------------------------------

事件对象event：包含着所有与事件相关的信息。

## DOM中的事件对象：

`event.type`:事件类型
`event.state`

- 事件处理程序内部，对象this始终等于`currentTarget`（事件处理程序正在处理事件的元素）的值，而`target`（事件的目标）只包含事件的实际目标。
- 如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值
- 如果事件处理程序存在于按钮的父节点中，那么这些值是不相同的

- 阻止特定事件的默认行为，可以使用`preventDefault()`方法。
- 只有`cancelable`(默认行为是否可以取消)为true的事件，才可以使用`preventDefault()`取消默认行为。

- `stopPropagation()`用来立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。

事件对象的`eventPhase`，可以用来确定事件当前正位于事件流的哪个阶段。捕获阶段：1；处于目标对象：2；冒泡阶段调用的事件处理程序：3.

> 只有在事件处理程序执行期间，event对象才会存在；一旦执行完成，event对象就会被销毁。
> 事件处理程序的作用域是根据指定它的方式来决定的。

## IE中的事件对象

IE中，访问event对象的方式不同，取决于指定事件处理程序的方法。

- 使用DOM0级方法添加事件处理程序时，event对象作为window的一个属性而存在，`window.event`。
- `attachEvent()`方法：存在一个event对象传入。
- HTML特性指定的事件处理程序，还可以通过event变量来访问。

`srcElement`：事件的目标

`returnValue()`:`preventDefault()`

`cancelBubble()`：`stopPropagation()`，IE不支持事件捕获，所以只能取消事件冒泡。

---------------------------------------------------------------------------------------------------------

## 事件类型

DOM3级事件
- UI事件，用户与页面元素交互时发生
    - load：页面完全加载后在window上面触发，所有框架加载完毕时在框架集上触发，图像加载完毕时在`<img>`元素上触发，嵌入的内容加载完毕时在`<object>`元素上面触发。
    - unload：文档被完全卸载后触发。只要用户从一个页面切换到另一个页面，就会发生unload事件，利用最多的是清除引用，防止内存泄漏。
    - abort：用户停止下载过程时
    - error
    - select：用户选择文本框中的一个或多个字符时触发
    - resize：窗口或框架的大小变化时在**window**或框架上触发。浏览器窗口最大最小化也会触发。
    - scroll
- 焦点事件
    - blur：元素失去焦点时触发，不会冒泡，所有浏览器都支持
    - focus：元素获得焦点时触发，不冒泡
    - focusin：等价于focus，但是冒泡
    - focusout：等价于blur，但是冒泡
- 鼠标事件
    - click：单击鼠标按钮或按下回车键触发
    - dbclick
    - mousedown
    - mouseenter：首次移动到元素范围内触发，不冒泡，在后代元素上不会触发
    - mouseleave：不冒泡，在后代元素上不会触发
    - mousemove
    - mouseout：用户将鼠标指针从一个元素移动到另一个元素时触发
    - mouseover
    - mouseup：释放鼠标按钮时触发


p370
|event属性|含义|
|:----:|:-----:|
|clientX & clientY|鼠标指针在浏览器视口中的位置|
|pageX & pageY|鼠标光标在页面中的位置|
|screenX & screenY|鼠标指针相对于整个屏幕的坐标信息|
|shiftkey & ctrlkey & altkey & metakey|是否按下了相应的键|


- 滚轮事件
- 文本事件
    - textInput：用户在可编辑区域中输入字符时，就会触发这个事件
    - event.data:值为用户输入的字符
    - event.inputMethod:文本输入到文本框中的方式
- 键盘事件
    - keydown：按下键盘任意键触发
    - keypress：按下键盘的字符键触发
    - keyup：释放键盘的键触发 
- 合成事件：输入字符时触发
- 变动事件：底层DOM结构发生变化时触发

---------------------------------------------------------------------------------------------------------

## HTML5事件

- contextmenu事件

表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。

contextmenu事件是冒泡的

`event.preventDefault()`来取消这个事件，事件对象包含与光标位置有关的所有属性。使用click事件来隐藏该菜单。

- beforeunload事件

window对象上的事件

事件在浏览器卸载页面之前触发，可以通过他取消卸载并继续使用原页面

- DOMContentLoaded事件

在形成完整的DOM树之后就会触发

- readystatechange事件

- hashchange事件

方便在url的参数列表（#后面的所有字符串）发生变化时通知开发人员

必须把hashchange事件处理程序添加给window对象，event对象两个额外属性：oldURL和newURL，保存着变化前后的完整URL。

---------------------------------------------------------------------------------------------------------

## 设备事件

- orientationchange事件

event不包括任何额外的信息

window.orientation：0,90，-90

- MozOrientation事件

- deviceorientation事件

- devicemotion事件

---------------------------------------------------------------------------------------------------------

## 触摸与手势事件

触摸事件：都会冒泡都可以取消
- touchstart
- touchmove
- touchend
- touchcancel

手势事件：
- gesturestart：一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发
- gesturechange：触摸屏幕的任何一个手指的位置发生变化时触发
- gestureend：任何一个手指从屏幕上面移开时

---------------------------------------------------------------------------------------------------------

## 内存和性能

事件处理程序过多会影响页面的性能。

事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

对于多个会触发事件的元素，使用事件委托，只需要在DOM树中尽量最高的层次上添加一个事件处理程序。

由于所有列表项都是这个元素的子节点，而且他们的事件会冒泡，所以事件最终会被这个高层函数处理。p403这种技术需要占用的内存更少。

如果可行，可以在document对象上添加事件处理程序：
- document很快就可以访问，只要可以单击的元素出现在页面上，就可以立即具备适当的功能。
- 页面中设置事件处理程序所需的时间更少。
- 整个页面占用的内存空间更少，能够提升整体性能


内存中留有过时不用的“空事件处理程序”，也是造成web应用程序内存与性能问题的主要原因。两种情况：
- 文档中移除带有事件处理程序的元素时。
    - `removeChild()`，`replaceChild()`
    - innerHTML替换带有事件处理程序的元素，那么原来的事件处理程序极有可能无法被当做垃圾回收
    - 所以这种情况，要手动先把事件处理程序移除。事件委托也可以解决这个问题。
- 卸载页面的时候
    - 页面卸载之前没有清理干净事件处理程序，那么他们就会滞留在内存中。
    - 最好的做法是在页面卸载之前，先通过onunload事件处理程序移除所有事件处理程序。

> 事件处理程序中删除按钮也能阻止事件冒泡，目标元素在文档中是事件冒泡的前提。

---------------------------------------------------------------------------------------------------------

## 模拟事件

使用JavaScript在任意时刻触发特定的事件，在测试web应用程序时非常有用。

- 可以在document对象上使用`createEvent()`创建event对象，接收一个参数，即表示要创建的事件类型的字符串，如UIEvents、MouseEvents、MutationEvents、HTMLEvents。
- 使用与事件有关的信息对其进行初始化。
- 最后，触发事件，使用`dispatchEvent()`方法，需要传入一个参数，表示要触发事件的event对象。