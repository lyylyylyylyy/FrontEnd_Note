# 网络部分+浏览器

OSI七层模型与TCP/IP五层模型
- 1）物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输
- 2）数据链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路
- 3）网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。
- 4）传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文,tcp,udp
- 5）会话层：任务就是向两个实体的表示层提供建立和使用连接的方法。
- 6）表示层：它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层
- 7）应用层：应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务http、网络管理服务、数据库服务等DHCP,TFTP,SNMP,DNS，POP3 ,FTP, HTTP, Telnet, SMTP

从输入URL到页面加载发生了什么？
- DNS解析，获得url的ip地址，若是本地缓存中存在，则从缓存中取得，若是本地缓存中无，则从向域名服务器请求查询ip地址
- 建立tcp连接
- 发送http请求
- 服务器处理请求并返回http报文
- 浏览器根据服务器的响应渲染页面

dns具体的查询过程：
- 根域名服务器，顶级域名服务器，二级域名服务器。。。。
- 迭代查询：靠自己，客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表
- 递归查询：靠别人，客户端只发一次请求，要求对方给出最终结果
  - 主机向本地域名服务器的查询一般都是采用递归查询
- [参考](https://zhuanlan.zhihu.com/p/61394192)

URL由三部分组成：协议类型，主机名和路径及文件名。通过URL可以指定的主要有以下几种：http、ftp、gopher、telnet、file等。

http和tcp关系：
- tcp协议属于传输层协议
- http协议属于应用层协议
- 必须通过tcp协议构建起连接后，http请求才可以发起成功

[http数据包格式](https://www.cnblogs.com/jpfss/p/10984966.html)

tcp和udp区别：
- tcp是有连接的，而udp是无连接的
- tcp可靠可以保证数据的完整性，而udp不可靠无法保证数据的完整性
- tcp面向字节流，而udp面向报文
- tcp首部最小20字节，而udp首部开销小，仅是8字节
- tcp适用于要求可靠传输的应用，如文件传输，而tcp适用于实时应用，如电话直播，dns等
- tcp只能是一对一通信，udp支持一对一、一对多等交互通信

现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？
- 请求头中的Connection属性决定了连接是否持久
- http/1.0中，Connection默认是close 的，即每次请求都会重新建立和断开tcp
- http/1.1中，Connection默认是keep-alive的，即tcp连接可以复用，不用每次都要重新建立和断开tcp连接
- 一般情况下，复用的tcp连接等待设置的超时时间后还没有任何连接的话，就会主动断开

一个 TCP 连接可以对应几个 HTTP 请求？
- 如果维持连接的话，一个 TCP 连接是可以发送多个 HTTP 请求的

一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
- http/1.1中，单个tcp连接在同一时刻只能处理一个请求
- http/2.0中，提供了multiplexing多路传输特性，可以在一个tcp连接中同时完成多个http请求

浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
- 有，Chrome最多允许同一个host建立6个tcp连接

http、https区别
- http是超文本传输协议，信息是明文传输，https是具有安全性的ssl加密传输协议
  - 公钥和私钥：证书就是公钥，客户端判断证书是否有效，然后生成随机值（私钥），用公钥加密，发给服务器，服务器获取到私钥，用私钥加密传输内容。
  - 公钥加密算法，也就是 非对称加密算法，这种算法加密和解密的密码不一样，一个是公钥，另一个是私钥：
    - 公钥和私钥成对出现，证书有数字签名
    - 公开的密钥叫公钥，只有自己知道的叫私钥
    - 用公钥加密的数据只有对应的私钥可以解密
    - 用私钥加密的数据只有对应的公钥可以解密
    - 如果可以用公钥解密，则必然是对应的私钥加的密
    - 如果可以用私钥解密，则必然是对应的公钥加的密
  - https协议中，前面的握手过程中，服务器会将公钥发给客户端，客户端验证后生成一个密钥用公钥加密后发送给服务器，成功后建立通信。通信过程中，客户端将请求数据用得到的公钥加密后，发送给服务器，服务器用私钥解密，服务器用客户端给的密钥加密响应报文，发回给客户端，客户端用自己存的密钥解密。结果就是，你收发的数据他能看到，但是他不能解密。
  - 其实整个非对称加密过程都是为了最后的对称加密服务的，最终目的是证明证书中的公钥是安全且未篡改。使用公钥来加密一个秘钥，并把秘钥传给后端，后端使用私钥解密秘钥，这样两端都拥有同一个秘钥，从而进行对称加密。所以私钥是绝对不能泄漏的，不然完蛋。
  - http的header中加入“strict-transport-security”声明，可以避免中间人将https反向代理到http
- https协议需要到ca机构申请证书
- http的端口是80，https的端口是443
- https连接简单，无状态，https由ssl+http构建的可进行加密传输，身份认证的协议，比http安全

中间人攻击：
- 中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信；将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。 
- 通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。 
- 使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。

http1.0、http1.1和http2的区别
- http1.0: 
  - 短链接，Connection默认是close
  - 主要使用header里面的If-Modified-Since，Expires作为判断缓存的标准
  - 带宽浪费：将整个对象送过来
  - 认为每台服务器都绑定一个唯一的ip地址，所以，请求消息中不传递主机名
- http1.1: 
  - 长连接：Connection是keep-alive
  - 引入了更多的缓存控制策略，如Entity tag， If-Match、If-Not-Match等
  - 请求头中引入了range，允许只请求资源的某个部分，即返回码是206，用途：文件断点续传
  - 新增了24个错误状态响应码
  - 请求和响应头域都支持host头
- http2:
  - 解析采用二进制格式
  - 多路复用，连接共享
  - 服务端推送
  - header压缩，通讯双方各自缓存一份header fields的表，避免重复header的传输

浏览器的缓存机制(http缓存机制)：
- 利用http报文的缓存标识进行的
- 浏览器每次发起请求，都会先在浏览器的缓存中查找请求的结果和缓存标识，没有，才去向服务器请求
- 浏览器每次拿到请求的结果，都会将该结果和缓存标识放入浏览器缓存中
- 强制缓存：向浏览器缓存查找该请求结果，并根据该结果的缓存规则决定是否使用缓存结果的过程。
  - 1. 不存在该缓存结果和标识，强制缓存失效，直接向服务器发起请求
  - 2. 存在该缓存结果和标识，但是已经失效，强制缓存失效，使用协商缓存
  - 3. 存在该缓存结果和标识，且没有失效，强制缓存生效，直接返回结果
  - 控制强制缓存的字段：Expires(缓存的到期时间)、Cache-Control(public、private、no-cache、no-store、max-age)，Cache-Control的优先级更高
    - cache-control字段，在http请求中充当着缓存控制的角色，是控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式
  - 浏览器读取缓存的顺序是：先从内存中读取，再从硬盘中读取，内存中读取，读取速度很快，但是进程结束，内存中的缓存就被清空，js和图片用内存缓存，css用硬盘缓存
- 协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器决定是否使用缓存的过程
  - 协商缓存生效，返回304；协商缓存失效，返回200和请求结果(资源已经更新了)
  - 控制协商缓存的字段：Last-Modified/If-Modified-Since，弱校验器，只能精确到1s、Etag/If-None-Match（唯一缓存标识，优先级更高），强校验器
  - Last-Modified/If-Modified-Since是一个时间，Etag/If-None-Match的区别：是一个唯一缓存标识
    - last-modified标记着文件在服务端最后被修改的时间，浏览器第二次请求上次请求过的资源时,浏览器会在HTTP请求头中添加一个If-Modified-Since的标记,用来询问服务器该时间之后文件是否被修改过
    - etag：是一个服务器端生成的序列值，浏览器第二次请求上次请求过的url时，浏览器会在HTTP请求头添加一个If-None-Match的标记，用来询问服务器该文件有没有被修改。
    - ETag头的另一个典型用例是缓存未更改的资源。 如果用户再次访问给定的URL（设有ETag字段），显示资源过期了且不可用，客户端就发送值为ETag的If-None-Match header字段。服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用（新鲜）。
    - Etag主要为了解决Last-Modified无法解决的一些问题:
      - 有些文件的修改非常频繁，有可能在1s内修改了n次，if-modified-since能检测到的粒度是秒级的，这种修改它无法判断
      - 一些文件也许周期性的改变，但是他的内容并不改变（只是修改时间），这时候我们不希望客户端认为这个文件被修改了，而重新获取资源
      - 某些服务器不能精确的得到文件的最后修改时间

no-cache 和 no-store 都是 HTTP 协议头 Cache-Control 的值。区别是：
- no-store：彻底禁用缓冲，所有内容都不会被缓存到缓存或临时文件中。
- no-cache：在浏览器使用缓存前，会往返对比 ETag，如果 ETag 没变，返回 304，则使用缓存。


禁止缓存的方式：
- 请求和响应的头中，设置cache-control为no-cache
- 利用meta标签：`<meta http-equiv = 'cache-control' content='no-cache, no-store, must-revalidate'/>`
```html
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
```

[TCP 三次握手和四次挥手](https://hit-alibaba.github.io/interview/basic/network/TCP.html)

状态码307与302之间的唯一区别在于，当发送重定向请求的时候，307状态码可以确保请求方法和消息主体不会发生变化。 如果使用302响应状态码，一些旧客户端会错误地将请求方法转换为GET：

tcp的准确传输机制
- 停止等待协议：每发送完一个分组就停止发送，等待对方确认，在收到对方确认后再发送下一个分组。发送方在一定时间没有收到确认，则会重传分组
- 回退n协议
- 超时重传机制
- 流量控制：流量控制就是指在接收方能够接收的范围内，合理而又快速的发送数据。滑动窗口
- 拥塞控制：拥塞控制是指防止过多的数据注入网络中，这样可以使网络中路由器或者链路不致过载。动态改变窗口大小
- 校验和

ip分组：
- 子网掩码：它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。
- 类别
- 子网掩码工作过程是：将32位的子网掩码与IP地址进行二进制形式的按位逻辑“与”运算得到的便是网络地址，将子网掩码二进制按位取反，然后IP地址进行二进制的逻辑“与”（AND）运算，得到的就是主机地址。如：192.168.10.10 AND 255.255.255.0，结果为192.168.10.0，其表达的含义为：该IP地址属于 192.168.10.0这个网络，其主机号为10，即这个网络中编号为10的主机

```
子网掩码的二进制数值
子网掩码的十进制数值
A
11111111 00000000 00000000 00000000
255.0.0.0
B
11111111 11111111 00000000 00000000
255.255.0.0
C
11111111 11111111 11111111 00000000
255.255.255.0
```
[get和post的区别](https://www.jianshu.com/p/065fc0555056)：
- 浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】
- get请求会被浏览器主动缓存，而post不会。【重要】
- get请求的参数，会被保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。
- get请求在url中传递的参数有大小限制，基本是2kb`，不同的浏览器略有不同。而post没有注意。
- get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。
- 可能知道POST请求要比GET请求慢一下，这是什么原因导致的呢？因为GET请求产生一个TCP数据包，而POST请求会产生两个TCP数据包。对于GET请求，浏览器会把Http header和data一并发送出去，服务器响应200（ok）；而对于POST请求，浏览器先发送header，服务器响应100（continue），浏览器再发送data。正是因为POST请求会发送两次包，所以相对会慢一些。但是需要注意，并不是所有浏览器都会在POST请求中发送两次包，Firefox就只发送一次



xss和csrf攻击：
- xss：跨站脚本攻击
  - 存储型：将恶意代码提交到数据库中
  - 反射型：构造出包含恶意代码的url，参数中拼接了恶意代码
  - dom型：恶意代码修改DOM结构，单纯发生在客户端，利用`script`标签等
  - 防范：
    - 拼接html时，要对html进行充分转义
    - 将用户输入插入html或者拼接js时，要进行编码，将一些特殊字符转义
    - 设置HttpOnly防止截取cookie
    - 用户的任何输入都要检查，过滤和转义
    - SameSite Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送
- csrf：跨域请求伪造
  - 防范：
    - 同源验证：origin和referer会标记来源域名，确定请求源是否符合要求
    - 服务器生成一个token，利用加密算法加密token，通过验证token是否正确确认身份


HTTP 的状态码


cookie 和 webStorage 的区别：
- webStorage的数据保存在本地，不会与服务器发生交互，cookie的数据会在浏览器和服务器中来回传递
- webStorage的存储空间更大，可以达到5M，而cookie数据大小不超过4K
- cookie不可以跨域调用，但是webStorage可以跨域调用
- cookie中的数据在过期时间之前有效，sessionStorage在浏览器关闭之后就消失了，localStorage持久存储数据，除非主动删除数据

cookie：
- 服务器使用`Set-Cookie`响应头部向用户（一般是浏览器）发送cookie信息
- Cookie的Secure 和HttpOnly 标记
  - Secure标记：cookie应该只通过被https协议加密过的请求发给服务端
  - HttpOnly：document.cookie无法获取
- Cookie的作用域 Domain 和 Path
  - 标识了cookie的作用域，即cookie应该发送给哪些url
- SameSite
  - SameSite Cookie 允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）
  - None 浏览器会在同站请求、跨站请求下继续发送 cookies ，不区分大小写。
  - Strict 浏览器将只发送相同站点请求的 cookie (即当前网页URL与请求目标URL完全一致)。如果请求来自与当前 location 的 URL 不同的 URL，则不包括标记为 Strict 属性的 cookie。
  - Lax 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者frames的调用，但只有当用户从外部站点导航到URL时才会发送。如link链接

某种请求默认不携带 cookie:
- fetch在默认情况下, 不管是同域还是跨域ajax请求都不会带上cookie, 只有当设置了 credentials 时才会带上该ajax请求所在域的cookie, 服务端需要设置响应头Access-Control-Allow-Credentials: true, 否则浏览器会因为安全限制而报错, 拿不到响应

Cookie 和 Session 有什么不同？
- 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。


# 操作系统部分

进程和线程的区别：
- 一个程序至少有一个进程，一个进程至少有一个线程
- 线程的划分尺度小于进程
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存
- 线程不能独立执行，必须依存在应用程序中

死锁：
- 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们将无法推进下去。
- 因为系统资源不足
- 进程运行推进顺序不合适
- 资源分配不当等
- 死锁的必要条件
  - 互斥条件：一个资源每次只能被一个进程使用
  - 请求与保持条件：一个资源因请求资源而阻塞时，对已获得的资源保持不放
  - 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺
  - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
- 死锁的预防和解除：
  - 不让4个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源，也要防止进程处于等待的情况下占用资源，所以要对资源进行合理分配。

# 设计模式

- 工厂模式
- 原型模式

# JavaScript部分

JavaScript中的事件循环：
- JavaScript单线程运行
  - js可以操作dom，多线程，一个线程添加dom，一个删除dom，发生资源的冲突
- 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务
- 任务分为2种：同步任务和异步任务，同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
- 异步执行的运行机制：
  - 所有同步任务都在主线程上执行，形成一个执行栈
  - 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件
  - 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
  - 主线程不断重复上面的第三步
- "任务队列"是一个事件的队列，"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。
- 只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取
- 所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数
- "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取
- "任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行，setTimeout()和setInterval()
- setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。


- 宏任务：`<script>`、setTimeout()、setInterval()、setImmediate()
- 微任务：Promise、process.nextTick
- 划分标准：宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务

Node.js的事件循环：
- timers：处理setTimeout()和setInterval()的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段
- I/O callbacks：回调函数都在这个阶段执行，除了定时器的回调函数
- idle, prepare
- poll：这个阶段是轮询时间，用于等待还未返回的 I/O 事件
- check：该阶段执行setImmediate()的回调函数
- close callbacks
- process.nextTick：在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前
- setImmediate：setImmediate方法则是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行
- 多个process.nextTick语句总是在当前"执行栈"一次执行完，多个setImmediate可能则需要多次loop才能执行完，正是设置setImmediate的原因
- promise在process.nextTick后执行
- setTimeout在 timers 阶段执行，而setImmediate在 check 阶段执行。所以，setTimeout会早于setImmediate完成。
[读文件例子](http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html)
```javascript
setImmediate(function(){
  console.log(1);
  process.nextTick(function(){
    console.log(2);
  });
});
process.nextTick(function(){
  console.log(3);
  setImmediate(function(){
    console.log(4);
  })
});
// 3 1 4 2   两个 setImmediate 在同一轮循环的同一个队列里面。只有清空了这个队列，才会进入下一个阶段
```

防抖节流实现：
- 比如搜索框，用户在输入的时候使用change事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器资源很强大，也不带这么玩的
- 防抖，一段时间内，事件又触发，重新计时（setTimeout）
- 节流：一段时间内，事件只执行一次（时间戳）
```javascript
function debounce(fn, delay) {
  // 维护一个 timer，用来记录当前执行函数状态
  let timer = null;

  return function() {
    // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量
    let context = this;
    let args = arguments;
    // 清理掉正在执行的函数，并重新执行
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, delay);
  }
}
let flag = 0; // 记录当前函数调用次数
// 当用户滚动时被调用的函数
function foo() {
  flag++;
  console.log('Number of calls: %d', flag);
}

// 在 debounce 中包装我们的函数，过 2 秒触发一次
document.body.addEventListener('scroll', debounce(foo, 2000));

function throttle(func, delay){
  let prev = Date.now();
  return function(){
    const context = this;
    const args    = arguments;
    const now     = Date.now();
    if(now - prev >= delay){
      func.apply(context, args);
      prev = Date.now();
    }
  }
}

```

async和await
- async函数返回一个 Promise 对象
- generator函数的语法糖，将*换成async，yield换成await
- async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里

Promise
- 对象状态不受外界影响，pending、fulfilled、rejected但种状态
- 一旦状态发生变化，状态便不会再改变
- resolve函数，将Promise的状态变成fulfilled
- reject函数，将Promise的状态变成rejected
- then函数
- catch函数：指定发生错误时的回调函数
- Promise.finally：不管Promise对象最后的状态如何，都会执行的操作
- Promise.all：`const p = Promise.all([p1, p2, p3]);`参数是一个promise实例数组，所有的promise状态都是fulfilled，p的状态才会变成fulfilled，有一个被rejected，p的状态就变成rejected
- Promise.race([p1,p2,p3])：`const p = Promise.race([p1,p2,p3])`，第一个改变状态的promise的返回值传递给p的回调函数，p的状态也跟随第一个改变的promise改变
- Promise.any([p1,p2,p3])：``const p = Promise.race([p1,p2,p3])`，有一个promise的状态是fulfilled，p的状态就会变成fulfilled，所有的promise状态都变成rejected，p的状态才会变成rejected
- Promise.allSettled()：只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束
- Promise.resolve()：有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用
- Promise.reject()：Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected
- Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。

es6的Module：
- 浏览器加载 ES6 模块，也使用`<script>`标签，但是要加入`type="module"`属性。
- 浏览器对于带有`type="module"`的`<script>`，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了`<script>`标签的defer属性。


es6中Module和CommonJS中Module的区别
- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有一个独立的模块依赖的解析阶段。
- CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export。
- 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。

跨域
- 同源策略：指的是“协议+域名+端口”三者相同
- 跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了
- 协议和端口造成的跨域问题“前台”是无能为力的
- script、link、img三个标签可以跨域
- jsonp：
  - 利用`script`标签
  - 两部分组成：回调函数和数据
  - 回调函数：响应到来时在页面中执行的函数
  - 数据：传给回调函数的JSON数据 ——p587
  - 通过动态`<script>`元素使用，src指定一个跨域url(http://..../json/?callback=handleResponse)
- CORS跨域资源共享：
  - 基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求是否应该成功
  - 发送请求时，给他附加一个额外的Origin头部，包含请求的源信息(协议、域名和端口)，以便服务器根据这个头部信息决定是否给予响应
  - 若是服务器接受这个请求，就在`Access-Control-Allow-Origin`头部中回发相同的源信息
  - 要请求位于另一个域中的资源，在open方法中的url设置为绝对url即可
  - 跨域xhr的限制：不能setRequestHeader()，请求响应不能携带cookie，头部信息无法访问到
  - CORS 通过一种叫做 Preflighted Requests 的透明服务器验证机制支持开发人员使用自定义的头部、 GET 或 POST 之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个 Preflight 请求。这种请求使用 OPTIONS 方法，发送下列头部：
  - CORS的请求头：
    - Origin
    - Access-Control-Request-Headers：自定义头部信息
    - Access-Control-Request-Method：请求自身的方法
  - CORS的响应头：
    - Access-Control-Allow-Origin
    - Access-Control-Allow-Methods：允许的方法，逗号隔开
    - Access-Control-Allow-Headers：允许的头部，逗号隔开
    - Access-Control-Max-Age：这个请求缓存的时间，秒
  - 默认，跨源请求不携带凭据（cookie，http认证及客户端ssl证明等）：
    - withCredentials设置为true，可以指定请求应该发送凭据
    - Access-Control-Allow-Credentials:true
  - 简单请求：请求方法：GET、POST、HEAD；没有自定义的请求头
  - 复杂请求：复杂请求我们也可以称之为在实际进行请求之前，需要发起预检请求的请求。
- window.postMessage:
  - 页面和其打开的新窗口的通信
  - 多窗口之间消息传递
  - 页面也嵌套iframe消息传递
  - 上述三个场景的跨域传递
  - `otherWindow.postMessage(message, targetOrigin, [transfer]);`
    - message：数据
    - targetOrigin：目标uri
    - transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。
- document.domain：主域名相同的跨域，两个页面都通过js强制设置document.domain为基础主域，就实现了同域
- nginx：
  - 反向代理接口跨域
  - 通过nginx配置一个服务器用做跳板（域名和domain1相同，端口不同），反向代理访问domain2接口，顺便可以修改cookie中的domain信息，方便当前域的cookie写入，实现跨域登陆，修改nginx.conf


[this的原理](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)
- this指的是函数运行时所在的环境
- JavaScript 语言之所以有this的设计，跟内存里面的数据结构有关系
- 对象在内存中的存储，变量obj仅是对象在内存中存储的地址，但是属性的值可以是一个函数，引擎将函数单独保存在内存中，然后将函数的地址放到存储对象内存中的value处，由于函数是一个单独的值，所以他可以在不同的环境中执行，所以需要一种机制，能够在函数体内部获得当前的运行环境，所以this出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境


[立即执行函数表达式（IIFE）](https://segmentfault.com/a/1190000003985390)
- 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。
- 当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。

call，apply，bind的区别
- apply：
  - 第一个参数是this，或者是要执行函数的作用域，第二个是数组/arguments，用来传递参数
- call：第一个参数同apply，后面的参数一个一个列出即可
- bind(this/环境)：this指向bind中的参数，创建了一个新实例，也可以传递参数，单纯列出即可
- 执行function时传入this值作为this值
- call(this, num1, num2)
- 可以扩充函数作用域   p117
- bind(this/环境)：创建一个函数实例，this值会被绑定到传给bind()的值，var x = sayColor.bind(o)     

try...catch...中如果异步代码出错怎么办？  ？？？
- try-catch一般只能捕获同步任务中的错误，若是try中的同步任务出现了异步错误，catch是无法捕获到的，主要是因为，异步函数抛出异常后，宏任务已经进入了执行栈，不在try-catch的栈中，微任务只能用自带的错误捕获捕获
- 使用window.onerror这个全局错误捕获函数
- try-catch 中的异常只会抛出一层
- promise这种就用自己专属的错误处理
- 宏任务这种可以用onerror，

全局错误的捕获
- onerror

- `encodeURI()`：用于整个URI，不会对本身属于URI的特殊字符进行编码，如冒号、正斜杠等。
- `encodeURIComponent()`：用于URI的某一段，会对他发现的任何非标准字符进行编码。
- `decodeURI()`：解码
- `decodeURIComponent()`：解码
- 数据发送给服务器之前，需要使用`encodeURIComponent()`对数据进行编码，否则可能会报错。

new 在执行时，会做下面这四件事：
- （1）开辟内存空间，在内存中创建一个新的空对象。
- （2）将这个空对象的原型，指向构造函数的prototype属性。
- （3）让 this 指向这个新的对象。
- （4）执行构造函数里面的代码，给这个新对象添加属性和方法。
- （5）返回这个新对象（所以构造函数里面不需要return）。

实现类的私有的方法/属性（深入）
- 函数作用域封装局部变量
- Symbol：凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突
- WeakMap：WeakMap类型, 该类型数据是一个键-值（key-val）对的集合，只不过他的键（key）是一个引用
- 它们不能被外部访问，也不能被对象自己的公共方法访问。它们可以被私有方法访问。私有方法是构造函数的内部函数。

DOM 标准的事件模型
- 事件流
  - 事件冒泡、目标阶段、事件捕获
- 事件处理程序
- 事件对象
  - event.stopPropagation：组织捕获和冒泡阶段的事件的进一步传播，不能阻止默认事件
  - event.preventDefault：取消事件的默认行为
  - Event.bubbles：一个布尔值，用来表示该事件是否会在 DOM 中冒泡

手写事件代理：
```html
　　<ul id="test">
        <li>
            <p>11111111111</p>
        </li>
        <li>
            <div>
                22222222
            </div>
        </li>
        <li>
            <span>3333333333</span>
        </li>
        <li>4444444</li>
    </ul>
```
```javascript
　　var oUl = document.getElementById('test');
    oUl.addEventListener('click',function(ev){
        var target = ev.target;
        while(target !== oUl ){
            if(target.tagName.toLowerCase() == 'li'){
                console.log('li click~');
                break;
            }
            target = target.parentNode;
        }
    })
```

JavaScript 保留两位小数的实现方法:
- 四舍五入
```
var num =2.446242342;
num = num.toFixed(2);  // 输出结果为 2.45
```

es6中箭头函数与普通函数的区别
- 箭头函数是匿名函数，不能用new创建实例
- 没有prototype
- 没有绑定自己的this，this的指向永远不会改变，指向箭头函数定义时的环境
- 没有arguments
- 不能使用yield

有什么问题是普通函数可以解决箭头函数不可以的
- 不能用箭头函数来定义对象字面量
- 不能用new构建实例

let、const、var
- let：
  - 只在let声明的代码块内有用
  - 不存在变量提升，访问未被定义的let变量会报错
  - 暂时性死区：只要块级作用域内部存在let命令，声明的变量就绑定在这一块区域，不再受外部影响
  - 只能声明一次，否则会报错
  - let声明的变量是挂在script上面的(script和global平级)
- const
  - 常量，声明后不能改变，所以声明时必须立刻赋值初始化，否则会报错
  - 变量不提升
  - 暂时性死区
  - 挂在script下面
  - 只在声明所在的块级作用域生效
- var
  - 变量提升，undefined
  - 挂在window下面
- 如何避免变量提升：使用严格模式“use strict”

ES6共有6种声明变量的方法
- let、const、var、function、import、class

set和map的区别
- set
  - 类似于数组，但是内部的值无重复
  - 通过add()方法，向set内部添加成员
  - set可以接受一个数组作为参数，用来初始化
  - Set.prototype.constructor：构造函数，默认就是Set函数
  - Set.prototype.size：返回Set实例的成员总数
  - Set.prototype.add(value)：添加某个值，返回 Set 结构本身
  - Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功
  - Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员
  - Set.prototype.clear()：清除所有成员，没有返回值
  - Array.from方法可以将 Set 结构转为数组。
  - Set.prototype.keys()：返回键名的遍历器
  - Set.prototype.values()：返回键值的遍历器
  - Set.prototype.entries()：返回键值对的遍历器
  - Set.prototype.forEach()：使用回调函数遍历每个成员
- map
  - 键值对的集合
  - Map.prototype.keys()：返回键名的遍历器。
  - Map.prototype.values()：返回键值的遍历器。
  - Map.prototype.entries()：返回所有成员的遍历器。
  - Map.prototype.forEach()：遍历 Map 的所有成员
  - Map 转为数组最方便的方法，就是使用扩展运算符（...）
  - 将数组传入 Map 构造函数，就可以转为 Map。

Symbol
- Symbol 值通过Symbol()函数生成，所以，对象的属性名现在可以是字符串也可以是Symbol对象，Symbol对象是独一无二的，不会产生属性名冲突
- Symbol不能使用new命令，否则会报错，因为Symbol是基本数据类型，不是对象
- Symbol()函数可以接受一个字符串作为参数，表示对Symbol实例的描述
- 若是Symbol函数的参数是一个对象，则会先调用toString方法，将其转化为字符串，然后才生成一个Symbol值
- Symbol函数的参数只是表示对当前Symbol的值描述，所以相同参数的Symbol函数返回的值并不相等
- Symbol值不能与其他类型的值进行运算，否则会报错
- Symbol.prototype.description，读取symbol的描述
- Symbol 值作为对象属性名时，不能用点运算符
- Symbol 作为属性名时，遍历对象的时候，该属性不会出现在for...in...，for...of...循环中，也不会被Object.keys(),Object.getOwnPropertyNames,JSON.Stringify返回
- Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名
- Reflect.ownKeys()：可以返回所有类型的键名，包括常规键名和Symbol键名
- Symbol.for()：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。

[闭包及应用](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
- 定义：有权访问另一个函数作用域中的变量的函数，与作用域链有关
- 常见：一个函数中创建另一个函数
- 函数被调用时，创建执行环境，使用arguments和其他命名参数初始化函数的活动对象(AO)
- [[Scope]]：作用域链
- 一个函数内部定义的函数将外部函数的活动对象(AO)添加到自己的作用域链中
- 外部函数执行完毕后，其活动对象不会销毁，因为匿名函数的作用域链仍然引用这个活动对象，直到匿名函数销毁，赋值为null可以通知垃圾回收例程将其清除
- 缺点：过度使用闭包可能会导致内存占用过多
- 副作用：闭包只能取得包含函数中任何变量的最后一个值，闭包保存的是整个变量对象  ——p181
- this：匿名函数的执行环境具有全局性，因此this对象通常指向window，每个函数在被调用时，都会取得两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量。但是把外部作用域中的this保存在闭包可以访问的变量里，就可以了。   ——p183
- 应用
  - 模仿块级作用域
  - 私有变量
  - 静态私有变量
  - 模块模式

```javascript
var count = (function() {
  var n = 1;
  return function () {
    return n++;
  }
})();
count(); // 1
count(); //2
count(); //3
```

深拷贝：
- 对象：递归
- JSON.stringify，然后再JSON.parse

浅拷贝：
- `=`
- Object.assign()：如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。
  - `Object.assign(target, ...sources)`：只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。
- - 拓展运算符...：{...obj}


es6新增属性
- let、const
- 箭头函数
- 拓展运算符
- set数据结构
- promise
- 字符串方法：startswith，endswith
- 数组方法：includes、Array.from
- 解构赋值

es6新增字符串方法：
- includes、startsWith、endsWith
- repeat：返回一个新字符串，表示将原字符串重复n次
- padStart(len, str)，padEnd() ：在字符串的开头和结尾以指定字符串补全到指定长度
- trimStart()和trimEnd()：消除字符串头和尾的空格，返回新字符串，不会更改原字符串
- replace方法

es6新增数组方法：
- Array.from()
  - 用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。
  - 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
  - 扩展运算符（...）也可以将某些数据结构转为数组，扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。
- Array.of()
  - Array.of()方法用于将一组值，转换为数组
- copyWithin() 
  - `Array.prototype.copyWithin(target, start = 0, end = this.length)`
  - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
  - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
  - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
- find() 和 findIndex()
  - 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined
  - find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。
  - 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1
- fill()
  - fill方法使用给定值，填充一个数组。
- includes():返回一个布尔值，表示某个数组是否包含给定的值
- flat()
  - 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响
  - flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1
  - 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。

```javascript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

es6对象新增方法：
- Object.is()
  - 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致
  - 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
- Object.assign(target, source1, source2)
  - 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
  - 如果只有一个参数，Object.assign()会直接返回该参数
  - 如果该参数不是对象，则会先转成对象，然后返回
  - 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错
  - 如果非对象参数出现在源对象的位置（即非首参数），这些参数都会转成对象，如果无法转成对象，就会跳过。如果undefined和null不在首参数，就不会报错
- Object.getOwnPropertyDescriptors()
  - 返回指定对象所有自身属性（非继承属性）的描述对象
- __proto__属性，Object.setPrototypeOf(object, prototype)，Object.getPrototypeOf()
- Object.keys()，Object.values()，Object.entries()
  - Object.keys()：返回一个数组，成员是参数对象自身的（不含继承的，只是在实例上的属性，不包括原型上的属性）所有可遍历（enumerable）属性的键名
- Object.fromEntries()
  - 用于将一个键值对数组转为对象。
```javascript
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

类数组转化为数组的方法
- Array.prototype.slice.call()
- Array.from()
- 扩展运算符（…）


怎么判断数组
- instanceof
- constructor
- Object.prototype.toString.apply(数组)
- Array.isArray()
- isPrototypeOf(): `Array.prototype.isPrototypeOf(arr)`

es6中Module声明的变量的作用域：
- 模块内声明的所有内容都是模块的内部变量，必须export后才能使用
- 模块顶层声明的变量在模块的顶级作用域中，this是undefined

函数作用域和块级作用域的区别
- 函数作用域指在函数内声明的所有变量在函数体内始终是可见的， 
- 块级作用域指在变量声明的代码段之外是不可见的。


手写instanceof方法：
```javascript
function myinstanceof(leftValue, rightValue) {
  var rightproto = rightValue.prototype;
  leftValue = leftValue.__proto__;
  while(true) {
      if (leftValue == null) return false;
      if (leftValue == rightproto) return true;
      leftValue = leftValue.__proto__;
  }
}
```
手写promise.all：
```javascript
promise2.all = function(arr) {
  let list = [];
  let len = 0;
  let hasErr = false;

  return new promise2((resolve, reject) => {
      for(var i=0;i<arr.length;i++) {
          arr[i].then(data => {
              list[i] = data;
              len++;
              len === arr.length && resolve(list);
          }, error => {
              !hasErr && reject(error);
              hasErr = true
          })
      }
  })
}

promise2.race = function(arr) {

    return new promise2((resolve,reject) => {
        for (var i=0; i<arr.length;i++) {
            arr[i].then(data => {
                resolve(data);
            }, error => {
                reject(error);
            })
        }
    })
}
```

继承：
- 原型链是实现继承的主要方法
  - 思想：子类型函数原型对象B等于另一个超类型构造函数类型A的实例（实例里面的`__proto__`，导致原型对象中也有了实例的`__proto__`，指向实例的原型对象，实现了继承），实现的本质是重写原型对象，代之以一个新类型的实例 ，重写后，新建的B实例的constructor指向改变了，指向A的构造函数，这是因为重写了原型  ——p163
  - 谨慎的定义方法    ——166
    - 子类型覆盖超类型中的某个方法，给原型添加的方法一定要放在替换原型的语句后面，子类型实例调用使用替换的方法，超类型实例调用使用的是原来的方法
- 构造函数：最常用
  - 思想：子类型函数内部调用超类型构造函数，使用`apply()`和`call()`函数在新创建的对象上执行构造函数
  - 优势：可以在子类型构造函数中向超类型构造函数传递参数
- 组合继承
  - 思想：原型链继承原型属性和方法，构造函数继承实例属性
  - 缺点：调用两次构造函数，不得不在调用子类型构造函数时重写这些属性
- 寄生式继承：function函数内部先通过Object.create(original)创建一个对象，然后给对象添加方法，返回这个对象
```javascript
 var person={
    name:'ccdida',
    friends:['shelly','Bob']
  }
  function createAnother(original){
    //clone.__proto__===original
    var clone=Object.create(original)
    //增强对象，添加属于自己的方法
    clone.sayHi=function(){
      console.log('hi')
    }

    return clone

  }
  var person1=createAnother(person)
  var person2=createAnother(person)
  person1.friends.push('shmily')
  console.log(person2.friends)//["shelly", "Bob","shmily"]
  person1.sayHi() //hi
```
- 寄生组合式继承：最有效

module.export和export的区别


js清除缓存的几种方法：
- 用ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control（no-caches）
- 直接用cache:false
- meta方法:
```
<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<META HTTP-EQUIV="expires" CONTENT="0">
```

[滚动条滑动懒加载](https://segmentfault.com/a/1190000020735968)

null和undefined的区别：
- null表示一个空的对象，转为数值时是0，而undefined是一个表示“无”的原始值，转为数值时是NaN

e.target与e.currentTarget的区别：
- Event.target 和 event.currentTarget 都是对一个触发事件的对象的引用
- Event.target 对触发事件的对象的引用(即它标识事件发生的元素)
- event.currentTarget 当事件遍历DOM时，标识事件的当前目标。它总是引用事件处理程序附加到的元素
- target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的，而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象（一般为父级）。

js的数组方法：
- toString()
- join
- push、pop
- shift、unshift
- sort、reverse
- concat
- slice、splice
- indexOf、lastIndexOf
- every、filter、forEach、map、some
- reduce

class（类）：
- typeof Class === 'function'
- class可以看作是一个语法糖
- 里面有一个constructor方法
- 类的数据类型就是函数，类本身就指向构造函数，使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致
- 类的所有方法都定义在类的prototype属性上面
- 在类的实例上面调用方法，其实就是调用原型上的方法
- prototype对象的constructor()属性，直接指向“类”的本身，这与 ES5 的行为是一致的
- constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加
- 类不存在变量提升
- 类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错
- 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。

原生js发送请求：
```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'www.baidu.com', true);
xhr.send();
xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            console.log('success');
            alert(xhr.responseText);
        }
    }
}
```

发送json数据：
```javascript
var requestURL = 'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json';
var request = new XMLHttpRequest();
request.open('GET', requestURL);
request.responseType = 'json';
request.send();

request.onload = function() {
  var superHeroes = request.response;
  populateHeader(superHeroes);
  showHeroes(superHeroes);
}

function populateHeader(jsonObj) {
  var myH1 = document.createElement('h1');
  myH1.textContent = jsonObj['squadName'];
  header.appendChild(myH1);

  var myPara = document.createElement('p');
  myPara.textContent = 'Hometown: ' + jsonObj['homeTown'] + ' // Formed: ' + jsonObj['formed'];
  header.appendChild(myPara);
}
```

隐式类型转换：

JavaScript监听对象属性的改变：
- Object.defineProperty()
- proxy：
```javascript
let handler = {
    get: function(target, name){
        return name in target ? target[name] : 37;
    }
};

let p = new Proxy({}, handler);

p.a = 1;
p.b = undefined;

console.log(p.a, p.b);    // 1, undefined

console.log('c' in p, p.c);    // false, 37
```

执行栈

作用域

闭包怎么确定作用域

深拷贝如果值是function怎么办，要注意解决哪些问题

浏览器解析js整个过程到底是怎么样的

promise原理

apply、bind原理，手写

预编译问题

闭包怎么预编译

- `typeof 函数`：function
- `typeof null`: object

懒加载

# CSS

CSS的优先级：
- 行内样式 > id选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签 = 伪元素选择器

[CSS选择器权重计算：](https://www.html.cn/qa/css3/16549.html)
- NO1，内联样式，权重值是1000
- NO2，id选择器，权重值是100
- NO3，类，伪类，属性选择器，权重值是10
- NO4，标签，伪元素选择器，权重是1
- 最后把这些值加起来，就是当前元素的权重了
- 无条件优先的属性只需要在属性后面使用!important。它会覆盖页面内任何位置定义的元素样式。
- 通配符，子选择器，相邻选择器等。如*，>,+, 权值为0000.
- 继承的样式没有权值


伪类和伪元素的区别：


文字换行：
- overflow-wrap
- word-break
- white-space

浏览器的渲染过程：
- 解析HTML生成DOM树。
- 解析CSS生成CSSOM规则树。
- 将DOM树与CSSOM规则树合并在一起生成渲染树。
- 遍历渲染树开始布局，计算每个节点的位置大小信息。
- 将渲染树每个节点绘制到屏幕。

- CSS被视为阻塞渲染的资源，应放到代码的头部尽快加载。
- 同步的JavaScript会暂停DOMTree的构建，应放到代码的尾部最后加载，或者使用async/defer属性异步加载JavaScript。
- 重排和重绘会给浏览器渲染线程造成很大的负担，尽量减少重排和重绘的触发次数


css会阻塞js的加载吗？为什么？
- 会，因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况


margin-top为负值的应用

盒子模型

css垂直居中

css水平居中

flex怎么实现居中

清除浮动的方式：
- 浮动元素的父元素添加高度
- 插入一个新的div元素，并设置clear：both
- clear：both
- overflow：hidden

BFC：块级格式化上下文
- 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素
- 触发BFC的元素：
  - html
  - float
  - 绝对定位：absolute、fixed
  - display：flex、inline-block、table-cells
  - overflow：除了visible之外的值
- 可以用bfc解决高度塌陷问题（两个盒子的margin会叠加）
- 避免文字环绕
- 包含浮动元素的话，浮动元素不会乱跑


opacity visibility display 隐藏的区别
- opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的。
- visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件，设置为gone时，不保留控件空间。
- display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。

position：
- static：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置
- fixed：元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。
- absolute：元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
- relative：相对于其原本的位置来定位
- sticky：一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。该值总是创建一个新的层叠上下文（stacking context）

CSS布局，左边固定，右边自适应如何实现：
- 左position:absolute, 右margin-left
- 左边float，触发父元素宽度计算
- 左右float，右边使用负边距
- flex布局

flex:1代表什么？
- flex：flex-grow、flex-shrink、flex-basis
- flex-grow默认是0，存在剩余空间也不放大
- flex-shrink默认是1，空间不足，该元素会缩小
- flex-basis：分配上两个属性空间前，计算项目是否有多余，默认为auto
- flex：1 == flex：1 1 auto

如何解决移动端0.5px的问题
- scaleY(0.5)

rem、em、%、vw/vh相对于谁
- rem：相对于根元素的字体大小，默认1 rem = 16px
- em：em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小
- %：left，right，top，bottom，相对于父元素宽高，padding、margin只相对于父元素的宽
- vw/vh：视口宽度，认为一个视口是100vw、100vh



左边固定宽度，右边自适应：
- 左边{position：absolute}，右边：margin-left:左边的宽度，父元素：相对定位
- 左边{float：left}，右边：margin-left：左边的宽度，父元素：清除浮动
- flex布局

三栏式布局：

移动端适配：


transform：
- scale
- translate
- rotate

transition；
- transition-timing-function
- transition-property
- transition-duration
- transition-delay

animation：
- animation-delay
- animation-direction
- animation-duration
- animation-iteration-count
- animation-timing-function
- animation-name
- animation-play-state
- animation-fill-mode
- @keyframes来定义animation-name

[js动画可以实现比css更加复杂的功能](https://zh.javascript.info/js-animation)：
- 可以实现沿着不同时序函数的复杂路径移动
- 利用js操作style属性的不断变化，利用setTimeInterval
- requestAnimationFrame
  - `let requestId = requestAnimationFrame(callback)`
  - 这会让callback函数在浏览器每次重绘的最近时间运行
  - 如果我们对 callback 中的元素进行变化，这些变化将与其他 requestAnimationFrame 回调和 CSS 动画组合在一起。因此，只会有一次几何重新计算和重绘，而不是多次。

对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。
常见的触发硬件加速的css属性：
- transform
- opacity
- filters
- Will-change



CSS3的新特性：
- border-radius
- box-shadow：`box-shadow: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色`
- flex
- transform： 
- transition
- animation
- border-image
- 定位

文字默认不换行：
- white-space：nowrap   设置不换行
- word-wrap：break-word  自动换行
- word-break：break-all    强制英文单词换行
- text-overflow：ellipsis  超出显示省略号


# HTML

html语意化：
- 语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
- HTML 中，例如，`<h1>` (en-US) 元素是一个语义化元素，赋予了它包裹着的文本“这个页面中最高级别标题功能“的角色 (或含义) 。它的语义会被在很多地方以不同的方式被使用到， 例如搜索引擎会把它包含的内容作为一个重要的关键词，从而影响这个页面在搜索结果中的排序（参见SEO），而且屏幕阅读器会使用它来帮助视障用户更好的使用这个页面。
-  用户体验：例如title、alt用于解释名词或解释图片信息的标签尽量填写有含义的词语、label标签的活用
-   有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重


HTML5的新特性：
- 新增语义标签
  - `header`、`footer`、`nav`(导航)、`section`
- 新增的表单属性
  - placeholder、required、maxlength、multiple等
- 提供了视频和音频播放的标准
  - `audio`、`video`
- 新增了canvas（没用过）
- web storage：sessionStorage、localStorage
- websocket（不问不说）


link标签和script标签对页面的影响：
- `<script>`标签的加载、解析和运行都会阻塞DOM的解析和渲染。这是因为js可以操作DOM，浏览器为了防止渲染过程出现不可预期的结果，让GUI渲染线程和js引擎线程互斥，即解析器在遇到`<script>` 标记时会立即解析并执行（或请求）脚本。文档的解析将停止，直到脚本执行完毕后才会继续。
- `<link>`标签不会阻塞DOM解析但会阻塞DOM渲染,DOM的解析和CSSOM的解析是一个并行的过程
- `<link>`标签会阻塞js的执行，浏览器在`<link>`标签的加载和解析过程中，会禁止脚本运行。
- 嵌入 JS 会阻塞所有内容的呈现(写在body标签内部)，而外部 JS 只会阻塞其后内容的显示，所以js尽量放在后面
- 浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况

js会阻塞页面的渲染吗？为什么？
- 会，js的执行会阻碍dom树的生成
- 嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示
- 渲染引擎遇到`<script>`标签就会停下来，等到执行完脚本，再继续向下渲染
- `<script>`标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。
- defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。

页面渲染时js阻塞的解决方法
- onload异步加载
- async/defer
- js放在最后的位置


回流重绘

dom模型

事件委托：
- 把一个元素响应事件的函数委托到另一个元素
- 一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数。
- 事件委托利用的是事件冒泡的机制，可以减少内存消耗，以及动态绑定事件
- 基本实现

获取dom节点的方法
- document.getElementById
- document.getElementByClassName
- element.getElementByName
- 父节点.childNodes
- 子节点.parentNode
- 邻居节点.nextSibling
- document.querySelector
- removeAttribute
- removeChild
- node.remove();

DOMContentLoaded和window.onload的区别？

DOM 文档的加载步骤

meta标签
- 描述html文档的元数据
- 在 HTML5 中，有一个新的 charset 属性，它使字符集的定义更加容易，规定了 HTML 文档的字符编码。
- 在移动端开发时，我们需要在头部加上一句`<meta name="viewport" content="width=device-width, initial-scale=1.0">`
  - width：控制viewport的大小，可以指定的一个值或者特殊的值，如device-width为设备的宽度（单位为缩放为100%时的CSS像素）。
  - height：和width相对应，指定高度。
  - initial-scale：初始缩放比例，也即是当页面第一次load的时候缩放比例。
  - maximum-scale：允许用户缩放到的最大比例。
  - minimum-scale：允许用户缩放到的最小比例。
  - user-scalable：用户是否可以手动缩放。
- 定义关键词：`<meta name="Keywords" content="网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信" />`
- 定义描述

SEO搜索引擎优化：
- 代码优化：
  - title标签
  - `<meta keywords>`
  - `<meta description>`
  - img标签中的alt
- 用history路由实现


如何快速判断 DOM 元素位于 viewport 以外？
- 使用 getBoundingClientRect() 方法来获取元素的位置，然后与浏览器高度（宽度）进行比较
```
ele.getBoundingClientRect().top > window.innerHeight // 元素在当前屏下面

ele.getBoundingClientRect().bottom < 0 // 元素在当前屏上面
```
- IntersectionObserver:相交检测
  - 图片懒加载——当图片滚动到可见时才进行加载
  - 内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉
  - 检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况
  - 在用户看见某个区域时执行任务或播放动画
  - 当以下情况发生时会被调用
    - 每当目标(target)元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根(root)。
    - Observer第一次监听目标元素的时候
    - 创建一个 IntersectionObserver对象，并传入相应参数和回调用函数，该回调函数将会在目标(target)元素和根(root)元素的交集大小超过阈值(threshold)规定的大小时候被执行。
    - 为每个观察者配置一个目标
```
let options = {
    root: document.querySelector('#scrollArea'),
    rootMargin: '0px',
    threshold: 1.0
}

let observer = new IntersectionObserver(callback, options);

let target = document.querySelector('#listItem');
observer.observe(target);
```

# 实际情况处理

开发的移动端网页放到公网，用户反馈说手机访问时白屏，该如何处理

性能优化的方法

减少首屏时间


IP地址如127.0.0.1，将其转换为十进制的整数

大数相加

给一个合法url，然后验证其请求的是一个以.qq.com结尾的url

前端性能指标：
- 首屏渲染时间
- first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间，
- first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas.
- 响应时间
  

前端性能优化的方法
- 减少http请求
- 静态资源使用CDN
- 图片：尽可能的使用PNG格式的图片，它相对来说体积较小
- 使用 HTTP2
- 将 CSS 放在文件头部，JavaScript 文件放在底部
- 善用缓存
- 尽可能利用 CSS3 效果代替图片
- 减少重绘重排
- 使用事件委托

# webpack

webpack的打包流程

# Vue

vue虚拟dom解决什么问题
- 虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attch 到 DOM 树上，再进行后续操作，避免大量无谓的计算量。所以，用 JS 对象模拟 DOM 节点的好处是，页面的更新可以先全部反映在 JS 对象(虚拟 DOM )上，操作内存中的 JS 对象的速度显然要更快，等更新完成后，再将最终的 JS 对象映射成真实的 DOM，交由浏览器去绘制。

[diff算法](https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f)

vue中的key有什么作用？
- 使用key来给每个节点做一个唯一标识，diff算法就可以正确的识别此节点，找到正确的位置直接操作节点，尽可能地进行重用元素，key的作用主要是为了高效的更新虚拟DOM。此外，使用index作为key是并不推荐的做法，其只能保证Vue在数据变化时强制更新组件，以避免原地复用带来的副作用，但不能保证最大限度的元素重用，且使用index作为key在数据更新方面和不使用key的效果基本相同。


vue的data为什么是一个函数？
- 每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。
- 而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰。

v-if 和v-show 区别：
- v-if 是动态添加，当值为false 时，是完全移除该元素，即dom 树中不存在该元素。 v-show 仅是隐藏/ 显示，值为false 时，该元素依旧存在于dom 树中。

vue.nextTick
- Vue 在更新 DOM 时是异步执行的
- Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新，是异步更新的
```javascript
//改变数据
vm.message = 'changed'

//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新
console.log(vm.$el.textContent) // 并不会得到'changed'

//这样可以，nextTick里面的代码会在DOM更新后执行
Vue.nextTick(function(){
    console.log(vm.$el.textContent) //可以得到'changed'
})
```

生命周期

MVC模式和MVVM模式：
- 以往的MVC模式是单向绑定，即Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。
- MVVM模式就是Model–View–ViewModel模式。它实现了View的变动，自动反映在 ViewModel，反之亦然。对于双向绑定的理解，就是用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。再说细点，就是在单向绑定的基础上给可输入元素input、textare等添加了change(input)事件,(change事件触发，View的状态就被更新了)来动态修改model。



[vue的响应式原理：](https://cn.vuejs.org/v2/guide/reactivity.html)
- 如何追踪变化：
  - 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter.
  - 在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。
  - 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染
- Vue 不能检测数组和对象的变化
- 对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property
- 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名
- Vue 不能检测以下数组的变动
  - 当你利用索引直接设置一个数组项时
  - 当你修改数组的长度时
- Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。

vue双向绑定：
- 数据劫持(Object.defineProperty)结合发布者-订阅者模式
- set探知数据改变，observer通知watcher
- Vue2.X通过 Object.defineProperty() 来劫持各个属性的setter，getter，新版本通过Proxy劫持
- 要想深入讲解知识点：
  - Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue追踪依赖，在属性被访问和修改时通知变化。
  - vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —>视图更新；视图交互变化（input）—>数据model变更双向绑定效果。
- 拓展：代码


vue中computed和watch的区别：
- computed是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed的值在getter执行后是会被缓存的。如果所依赖的数据发生改变时候, 就会重新调用getter来计算最新的结果。
- watch一个对象，键是 data 对应的数据，值是对应的回调函数。值也可以是方法名，或者包含选项的对象，当 data 的数据发生变化时，就会发生一个回调，他有两个参数，一个 val （修改后的 data 数据），一个 oldVal（原来的 data 数据）。Vue 实例将会在实例化时调用$watch()，遍历 watch 对象的每一个属性

导航守卫：
- 参数或查询的改变并不会触发进入/离开的导航守卫
- router.beforeEach：全局前置守卫
  - to: Route: 即将要进入的目标 路由对象
  - from: Route: 当前导航正要离开的路由
  - next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
  - 只要加了全局守卫，每次路由的跳转都要经过全局守卫
- beforeEnter 守卫
- 组件内的守卫
  - beforeRouteEnter：在渲染该组件的对应路由被 confirm 前调用
  - beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用
  - beforeRouteLeave：导航离开该组件的对应路由时调用


完整的导航解析流程
- 导航被触发。
- 在失活的组件里调用 beforeRouteLeave 守卫。
- 调用全局的 beforeEach 守卫。
- 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
- 在路由配置里调用 beforeEnter。
- 解析异步路由组件。
- 在被激活的组件里调用 beforeRouteEnter。
- 调用全局的 beforeResolve 守卫 (2.5+)。
- 导航被确认。
- 调用全局的 afterEach 钩子。
- 触发 DOM 更新。
- 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

vue-router中history和hash的区别：
- hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。hash模式背后的原理是onhashchange事件,可以在window对象上监听这个事件。只能改变#后面的url片段。
- history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。history的这种模式需要后台配置支持。

```javascript
history.pushState({color:'red'}, 'red', 'red')
history.back();
setTimeout(function(){
     history.forward();
 },0)
window.onpopstate = function(event){
     console.log(event.state)
     if(event.state && event.state.color === 'red'){
           document.body.style.color = 'red';
      }
}
```

Vue中的keep-alive：
- 组件实例在第一次被创建的时候缓存下来，防止重复渲染dom

```
<!-- 失活的组件将会被缓存！-->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>
```

v-for中的key是什么作用？
- 使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素。
- key的作用主要是为了高效的更新虚拟DOM
- key的特殊attribute主要用在Vue的虚拟DOM算法，在新旧Nodes对比时辨识VNodes
- index作为key，其实就等于不加key
- index作为key，只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出

vue项目中的package.json属性：
- [参考](https://blog.csdn.net/weixin_42003972/article/details/95164208)
- name：项目名称
- version：版本
- description：描述
- author：作者
- scripts：
  - dev
  - start
  - build
- dependencies：项目使用的依赖
- devDependencies：开发使用的依赖
- engines：项目依赖的引擎版本

vue-router的路由懒加载：
- 实现：
```
const Foo = () => import('./Foo.vue')

const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
})
```

[Vue常见的组件间通信的方式](https://juejin.cn/post/6844903887162310669)
