- 网络应用体系结构
  - 客户机/服务器
  - P2P(点对点结构 )
  - 混合结构
  
- 网络应用的服务需求
  - 可靠性
  - 带宽
  - 时延

- **Internet传输层服务模型**
  - TCP
  - UDP

- **特定网络应用协议**
  - HTTP
  - SMTP,POP,IMAP
  - DNS
  - P2P应用

- **Socket编程**
  - TCP
  - UDP

### 1. 网络应用体系结构

- 客户机/服务器
    - 服务器
      - 7*24小时提供服务
      - 永久性访问地址/域名
      - 利用大量服务器实现可拓展性


    - 客户机
      - 与服务器通信，使用服务器提供的服务
      - 间歇性接入网络
      - 可能使用动态IP地址
      - 不会与其他客户机直接通信

- P2P(点对点结构)
  - 纯P2P结构
    - 没有永远在线的服务器
    - 任意端系统/节点之间可以直接通信
    - 节点间歇性接入网络
    - 节点可能改变IP地址
  
- 混合结构

### 2. 网络应用进程通信

**网络应用的基础：进程间通信。**

进程：主机上运行的程序。

同一主机上运行的进程之间如何通信？
 - 进程间通信机制
 - 操作系统提供
  
不同主机上运行的进程间如何通信？
 - 消息交换

客户机进程：发起通信间的进程。

服务器进程：等待通信请求的进程。

**套接字：Socket**
  - 进程间利用socket发送/接受消息
  - 类似于寄信
    - 发送方将消息送到门外邮箱
    - 发送方依赖传输基础设施将消息传到接收方所在主机，并送到接收方的门外。
    - 接收方从门外获取信息
  - 传输基础设施向进程提供API
    - 传输协议的选择  
    - 参数的设置

**寻址进程**
- 不同主机上的进程间通信，每个进程必须拥有**标识符**。
- 寻址主机—— IP地址
- 端口号/port number
  - 为主机上每个需要通信的进程分配一个端口号
  - **HTTP Server：80**
  - Mail Server：25
- 进程的标识符
  - **IP地址+端口号**

### 3. 应用层协议
 
 网络应用需要遵循应用层协议。

 公开协议
- 由RFC(*Request For Comments*)定义
- 允许互操作
- **HTTP,SMTP……**

私有协议
- 多数P2P文件共享协议

**应用层协议的内容**
- 消息的类型
  - 请求消息
  - 响应消息
- 消息的语法(*syntax*)/格式
  - 字段
- 字段的语义
  - 字段中信息的含义
- 规则

### 4. 网络应用对传输服务的需求

数据丢失/可靠性
- 某些网络应用能够容忍一定的数据丢失：网络电话
- 某些要求100%可靠：文件传输，telnet
  
时延

带宽

### 4. Internet提供的传输服务

**TCP服务**
- 面向连接：客户/服务器进程间需要建立连接
- 可靠的传输
- 流量控制：发送方不会发送速度过快，超过接收方的处理能力
- 拥塞控制：当网络负载过重时能够限制发送方的发送速度
- 不提供时间/延迟保障
- 不提供最小带宽保障

**UDP服务**
- 无连接
- 不可靠的数据传输
- 不提供：
  - 可靠性保障
  - 流量控制
  - 拥塞控制
  - 延迟保障
  - 带宽保障
  
### 5. HTTP

网页包含多个对象：
- 对象：
- 基本HTML文件

对象的寻址：
- URL(*uniform resource locator*):统一资源定位器 RFC1738
- Schema：//host:port/path
  
**HTTP协议**
- 超文本传输协议
- C/S结构(*client-server*)
- **使用TCP传输协议**
  - 服务器在**80端口** 等待客户的请求
  - 浏览器发起到服务器的TCP连接
  - 服务器接受来自浏览器的TCP连接
  - 浏览器与Web服务器交换HTTP消息
  - 关闭TCP连接
- **无状态，不记录用户信息**
  - 服务器不维护任何有关客户端过去行为的信息

HTTP连接：
- 非持久性连接
  - 每个TCP连接最多允许传输**一**个对象
  - HTTP 1.0 版本使用非持久性连接
  - 每个对象需要2个RTT，时间长
  - 操作系统需要为每个TCP连接开销资源
  - 浏览器打开多个并行TCP，对服务器造成负担
- 持久性连接(*presistent http*)
  - 每个TCP连接允许传输**多个**对象
  - HTTP 1.1 版本默认使用持久性连接
  - 发送响应后，服务器保持TCP连接
    - **无流水的持久性连接**
      - 客户端只有收到前一个响应后才发送新的请求
      - 每个被引用的对象耗时一个RTT
    - 带有流水机制的持久性连接
      - HTTP 1.1的默认选项
      - 客户端只要遇到一个引用对象就尽快发出请求
      - 理想情况下，收到所有的引用对象只需耗时1个RTT

相应事件分析与建模：
- RTT(*Round Trip Time*)
- 响应时间
  - 发起、建立TCP连接
  - 发送HTTP请求消息到HTTP响应消息的前几个字节到达
  - 响应消息中所包含的文件/对象传输时间
  - total=2RTT + 文件发送时间

<img src='./img/响应时间.png'>

**HTTP请求消息**
- HTTP协议有两类消息
  - 请求消息
<img src = './img/HTTP请求消息.png'>
  - 响应消息
<img src = './img/HTTP响应消息.png'>
- 请求消息
  - ASCII：人直接可读


**上传输入的方法**
- **POST方法**
   - 网页经常需要填写表格
   - 在请求消息的消息体(*entity body*)中上传客户端的输入
- **URL方法**
  - 使用**GET**方法
  - 输入消息通过request行的URL字段上传
- **HEAD**
  - 请求Server不要将所请求的对象放入响应消息中
- **PUT(HTTP/1.1)**
  - 将消息体中的文件上传到URL字段所指定的路径
- **DELETE(HTTP/1.1)**
  - 删除URL字段指定的文件

**HTTP响应状态代码**
- 响应消息的第一行
- 示例：
  - 200 OK
  - 301 Moved Permanently
  - 400 Bad Request
  - 404 Not Found
  - 505 HTTP Version Not Supported
  - 500 Internet Server Error

### 6. Cookie

为什么需要Cookie？
- HTTP协议无状态，很多应用需要服务器掌握客户端的状态，如网上购物

Cookie技术：
- 某些网站为了辨别用户身份、进行session跟踪而储存在本地终端上的数据(通常经过加密)。
- RFC6265

**Cookie组件：**
- HTTP响应消息的cookie头部行
- HTTP请求消息的cookie头部行
- 保存在客户端主机上的cookie文件，由浏览器管理
- Web服务器端的后台数据库

Cookie的原理：
- <img src='./img/cookie原理.png'>

cookie能够用于：
- 身份认证
- 购物车
- 推荐
- web email
- ……
- 隐私问题

### 7. Web缓存/代理服务器技术

功能：
- 在不访问服务器的前提下满足客户端的HTTP请求
- 缩短客户请求的响应时间
- 减少机构/组织的流量
- 在大范围实现有效的内容分发


Web缓存/代理服务器技术
- 用户设定浏览器通过缓存进行Web访问
- 浏览器向缓存/代理服务器发送所有的HTTP请求
  - 如果请求对象在缓存中，缓存返回对象
  - 否则，缓存服务器向原始服务器发送HTTP 请求，获取对象，然后返回给客户端并保存该对象
- 缓存既充当客户端，也充当服务器

HTTP 的条件性Get方法
- 如果缓存有最新的对象，则不需要发送请求对象
- 缓存：
  - 在HTTP请求消息中声明所持有版本的日期
  - If-modified-since:<date>
- 服务器
  - 如果缓存的版本是最新的，则响应消息中不包含对象
  - HTTP/1.0 304 Not Modified
<img src='./img/条件性get.png'>