## 前言

**传输层服务的基本理论和基本机制**：
- 多路复用/分用
- 可靠数据传输机制
- 流量控制机制
- 拥塞控制机制

**掌握Internet的传输层协议**：
- UDP：无连接传输服务
- TCP：面向连接的传输服务
- TCP拥塞控制

## 传输层服务和协议

传输层协议为运行在不同Host(主机)上的进程提供了一种**逻辑通信机制**。

端系统运行传输层协议：
- 发送方：将应用递交的消息分成一个或多个segment，并向下传给网络层。
- 接收方：将收到的segment组装成消息，并上交给应用层。

**传输层可以为应用提供多种协议**：
- Internet上的TCP
- Internet上的UDP

**网络层 vs 传输层**

网络层：提供主机之间的额逻辑通信机制。

传输层：提供应用进程之间的逻辑通信机制
- 位于网络层之上
- 依赖于网络层服务
- 对网络层服务进行(可能的)增强

**Internet传输层协议**
- 可靠、按序的交付服务(TCP)
  - 拥塞控制
  - 流量控制
  - 连接建立
- 不可靠的交付服务(UDP)
  - 基于“尽力而为”的网络层，没有可靠性方面的拓展
- 两种服务均不保证
  - 延迟
  - 带宽

## 多路分用和多路复用

> 如果某层的一个协议对应直接上层的多个协议/实体，则需复用/分用。

### 分用如何工作：
- 主机接收到IP数据报
  - 每个数据报携带源IP地址、目的IP地址。
  -  每个数据报携带一个传输层的段(Segment）。
  -  每个段携带源端口号和目的端口号。

- 主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket。
  - TCP做更多处理

![](./img/TCP-UDP段格式.png)

### 无连接分用：
- 利用端口号创建Socket
```
DatagramSocket mySocket1 = new
DatagramSocket(99111);
DatagramSocket mySocket2 = new
DatagramSocket(99222);
```
- UDP的Socket用二元组标识(目的IP地址，目的端口号)
- 主机收到UDP段后,检查段中的目的端口号
- 将UDP段导向绑定在该端口号的Socket
- 来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket


### 面向连接的分用：
- TCP的Socket用四元组标识
  - 源IP地址
  - 源端口号
  - 目的IP地址
  - 目的端口号
- 接收端利用所有的四个值将Segment导向合适的Socket
- 服务器可能同时支持多个TCP Socket
  - 每个Socket用自己的四元组标识
- Web服务器为每个客户端开不同的Socket

## UDP

- **基于Internet IP协议**
  - 复用/分用
  - 简单的错误校验
- **“Best effort”服务，UDP段可能**
  - 丢失
  - 非按序到达
- **无连接**
  - UDP发送方和接收方不需要握手
  - 每个UDP段的处理独立于其他段
  
<br>

- 无需建立连接(减少延迟)
- 实现简单：无需维护连接状态
- 头部开销少
- 没有拥塞控制：应用更好的控制发送时间和速率

<br>

- 常用于流媒体应用
- UDP还用于
  - DNS
  - SNMP
- 在UDP实现可靠传输
  - 在应用层添加可靠性机制
  - 应用特定的错误恢复机制

![](./img/UDP.png)

### UDP校验和(checksum)

目的： 检测UDP段在传输中是否发生错误。

发送方：
- 将段的内容视为16-bit整数
- 校验和计算：计算所有整数的和，进位加在和的后面，将得到的值按位求反，得到校验和
- 发送方将校验和放入校验和字段

接收方：
- 计算所收到段的校验和
- 将其与校验和字段进行对比
  - 不相等：检测出错误
  - 相等：没有检测出错误（但可能有错误）

## 可靠数据传输原理

> 可靠传输：不丢、不乱、不错

![可靠数据传输基本结构](./img/可靠数据传输.png)

### rdt2.0

- 底层信道可能翻转分组中的位(bit)
  - 利用**校验和**检测**位错误**

- 如何从错误中恢复？
  - 确认机制(**Acknowledgements, ACK**): 接收方显式地告知发送方分组已正确接收
  - NAK:接收方显式地告知发送方分组有错误
  - 发送方收到NAK后，重传分组
  - 基于这种重传机制的rdt协议称为**ARQ**(Automatic Repeat reQuest)协议
   
- Rdt 2.0中引入的新机制
  - 差错检测
  - 接收方反馈控制消息: ACK/NAK
  - 重传

### rdt2.1和2.2

**rdt2.1**

- **如果ACK/NAK消息发生错误/被破坏(corrupted)会怎么样**？
  - 为ACK/NAK增加校验和，检错并纠错
  - 发送方收到被破坏ACK/NAK时不知道接收方发生了什么，添加额外的控制消息
  - 如果ACK/NAK坏掉，发送方重传
  - 不能简单的重传：产生重复分组

- **如何解决重复分组问题**？
  - 序列号(**Sequence number**): 发送方给每个分组增加序列号
  - 接收方丢弃重复分组

**rdt2.2**：无NAK消息协议

- 与rdt 2.1功能相同，但是只使用ACK
- 如何实现？
  - 接收方通过ACK告知最后一个被正确接收的分组
  - 在ACK消息中显式地加入被确认分组的序列号
  - 发送方收到重复ACK之后，采取与收到NAK消息相同的动作
  - 重传当前分组

### rdt3.0

如果信道既可能发生错误，也可能丢失分组，怎么办？
- “校验和+ 序列号+ ACK + 重传”够用吗？
  
- 方法：发送方等待“合理”时间
  - 如果没收到ACK，重传
  - 如果分组或ACK只是延迟而不是丢了
  - 重传会产生重复，序列号机制能够处理
  - 接收方需在ACK中显式告知所确认的分组
  - 需要定时器

![](./img/lost-package.png)
![](./img/lost-ack.png)
![](./img/premature-timeout.png)
